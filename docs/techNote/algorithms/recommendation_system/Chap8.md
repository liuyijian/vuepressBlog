# Chap8 推荐系统的评估

## 实验设置

#### 实验方式

* 离线实验（数据集回测）
* 用户调查（测试环境）
* 在线评估（生产环境）

#### 可靠结论

##### 配对结果

* 对于算法A和B需要进行配对的单用户性能测试，有一个简单的显著性检验，即符号测试
* 符号测试需要的假设是：1、用户独立，2、算法A优于算法B的次数$n_A$
* 我们先在算法A和B下分别为每个用户计算一个得分（如RMSE）
* 令用户数为$n$，系统A得分优于系统B至少$n_A$次的概率为：$p = (0.5)^n \sum\limits_{i = n_A}^{n} \frac{n!}{i! \cdot (n-i)!}$

* 当p值低于给定的阈值时，认为两个系统性能具有差异，而非随机性导致的结果
* 使用配对t检验，考察算法A和B性能得分的平均差异（premise：不同用户在得分上的差异具有可比性）
* 使用大数据集来获取更准确结果

##### 非配对结果

* 用户经常被分配到一个或其他算法上，因此两个算法不会在相同测试用例上进行评估
* 使用曼-惠特尼检验

##### 多重检验

* 使用邦弗朗尼校正，假设N+1个算法中最佳算法是基于调优集选择的，为了获得选择的算法确实为最好算法的置信度为 $1-p$ ， 那么它必须在评估集中优于其他N个算法且显著性为 $1 - (1-p)^{1/N}$

## 推荐系统属性

##### 用户偏好

##### 预测精度

* RMSE，MAE

|          | 被推荐       | 未被推荐     |
| -------- | ------------ | ------------ |
| 被使用   | 真阳率（tp） | 假阴率（fn） |
| 未被使用 | 假阳率（fp） | 真阴率（tn） |

* $precision = \frac{tp}{tp+fp}$       $recall = \frac{tp}{tp+fn}$         $F = \frac{2*precision*recall}{precision+recall}$  
* AUC:  ROC曲线下方的面积

* 推荐列表变长会提高recall，降低precision，若推荐列表定长，则应该计算top-N准确率
* 评估不同N值上的性能的CROC曲线
* 用户可以一直要求系统给出更多的文档，对每个用户计算ROC，然后计算所有用户结果曲线的均值

##### 排序指标

*  $>_1$ 是参考排序，$>_2$是系统排序，形式化定义如下

* 物品 $i_1$、$i_2$ 上，若满足 $i_1 >_1 i_2$ 且 $i_1 >_2 i_2$，则排序$>_1$，$ >_2$ 具有一致性，$\delta_{>_1,>_2}(i_1,i_2) = 0$
* 物品 $i_1$、$i_2$ 上，若满足 $i_1 >_1 i_2$ 且 $i_2 >_2 i_1$，则排序$>_1$，$ >_2$ 具有差异性，$\delta_{>_1,>_2}(i_1,i_2) = 1$
* 物品 $i_1$、$i_2$ 上，若满足 $i_1 >_1 i_2$ 且 $i_1 >_2 i_2$ 或 $ i_2 >_2 i_1 $ ，则排序$>_1$，$ >_2$ 具有相容性，$\delta_{>_1,>_2}(i_1,i_2) = 2$

###### NDPM

* 物品集 $I$ 里所有物品对上的总距离为 $\beta_{>_1,>_2}(I) = \sum\limits_{(i_1,i_2) \in \binom{I}{2}}\delta_{>_1,>_2}(i_1,i_2)$

* 定义指标 $NDPM(I,>_1,>_2) = \frac{\beta_{>_1,>_2}(I)}{argmax_> \beta_{>_1,>}(I)}$，分母为归一化因子，最佳值为0，最差值为1

###### AP

* 但NDPM并未考虑差异性出现在参考排序中的位置，为了修正这一点，选择平均正确率指标AP

  * $Z^i(I,>) = \{(i_1,i_2)\  \vert \ \ \forall i_1,i_2 \in I \ \ s.t. \ i_2 > i_1)\}$
  * 若物品$i_1,i_2$具有一致性，则 $\delta(i_1,i_2,>_1,>_2)=1$，否则为0
  * $A^{i_1}(I,>_1,>_2) = \frac{1}{\vert Z^{i_1}(I, >_2)\vert - 1} \sum\limits_{(i_1,i_2) \in Z^{i_1}(I, >_2)}\delta(i_1,i_2,>_1,>_2)$
  * $AP(I,>_1,>_2) = \frac{1}{\vert I \vert -1}\sum\limits_{i \in I}A^i(I,>_1,>_2)$

  * 若系统排序与参考排序完全一致，AP值为1，最差时为0

###### R-score

* 随着推荐列表中位置的下降而衰减非常迅速的方法来模拟用户仅注意到推荐列表上半部分少量物品的行为
* $R_u = \sum\limits_{j} \frac{max(r_{u,i_j}-d, \ 0)}{2^{\frac{j-1}{\alpha-1}}}$
  * $i_j$ : 位置 $j$ 上的物品
  * $r_{u,i}$ : 用户 $u$ 对物品 $i$ 的评分
  * $d$：任务相关的中立评分
  * $\alpha$：半衰期参数，控制着随排序列表的位置的指数衰减程度

* 归一化处理：$R = 100 \frac{\sum_u R_u}{\sum_u (R_u)^*}$

###### 归一化折扣累计收益（NDCG）

* $DCG =  \frac{1}{N} \sum\limits_{u=1}^{N} \sum\limits_{j=1}^{J} \frac{g_{u,i_j}}{log_b(j+1)}$

* $NDCG = \frac{DCG}{DCG*}$

* 适用于推荐列表较长，效用以对数形式衰减（如：搜索法律文件）

##### 覆盖率

* 一个计算物品空间覆盖率的方法是基尼系数

  * $G = \frac{1}{n-1} \sum\limits_{j=1}^{n}(2j-n-1)p(i_j)$

  * 其中，$i_1,\  \dots \ ,i_n$为物品列表，按照用户选择该物品的概率 $p(i)$ 来排序，也可简化为推荐次数
  * 当所有物品被等概率选择时，$G = 0$，若某个物品被经常选择，$G = 1$ 

  * 一个计算不均等分布的方法是香农熵： $H = -\sum\limits_{j=1}^{n}p(i) \log p(i)$

  * 若某个物品总被选择时 $H = 0$，若n个物品被均等选择，则 $H=\log n$